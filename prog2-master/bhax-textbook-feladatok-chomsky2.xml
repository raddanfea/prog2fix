<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
	<title>l334d1c4</title>
        <para>
	<programlisting>
        <![CDATA[
import java.io.*;
import java.util.*;

public class Main
{
    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        String OUP = "placeholder";
        while(OUP.charAt(0) != 'Q') {
            OUP = sc.nextLine();
            for(int i = 0; i < OUP.length(); i++) {
                switch (OUP.charAt(i)) {
                    case 'e':
                        OUP = OUP.substring(0, i) + '3' + OUP.substring(i + 1); break;
                    case 'E':
                        OUP = OUP.substring(0, i) + '3' + OUP.substring(i + 1); break;
                    case 'a':
                        OUP = OUP.substring(0, i) + '4' + OUP.substring(i + 1); break;
                    case 'A':
                        OUP = OUP.substring(0, i) + '4' + OUP.substring(i + 1); break;
                    case 'o':
                        OUP = OUP.substring(0, i) + '0' + OUP.substring(i + 1); break;
                    case 'O':
                        OUP = OUP.substring(0, i) + '0' + OUP.substring(i + 1); break;
                }
            }
            System.out.println(OUP);
        }
    }
}
	]]>
        </programlisting>
	</para>
	<para>
	Az alábbi l33t cypher Javában fut és sorokat fogad be, melyeket lefordít l33t nyelvre.
	</para>
	<para>
	A sort egy stringbe menti majd azt karakterenként átnézi lecserélendő karakterekért. Amikor cserélendő karaktert talál, a stinget kettévágja, a jelenlegi karaktert egy annak megfelelő l33t karakterre cseréli, majd az előtte és autána lévő résszel egyesíti azt.
	</para>
	<para>
	Amennyiben Q karaktert magában írjuk, a program kilép.
	</para>
	
    </section>
	<section>
        <title>Perceptron osztály</title>
	<para>
A perceptron az emberi agyi neuronokhoz mintázva épül fel.
	</para>
	<para>
A perceptron az egyik legegyszerűbb előrecsatolt neurális hálózat. Létrehozzuk a p nevű Perceptron osztály objektumot, a konstruktorának segítségével. Ez a perceptron 3 rétegű és egy kimeneti csomópontból áll, az egyes rétegek size változó értéke, 256, 1 szálakból állnak. Majd a számításhoz szükséges mátrixba mozgatjuk az adatokat, melyetket a heapen tárolunk, majd ezeket a helyeket felszabadítjuk a delete függvény segítségével manuálisan. A double típúsu változóba mentjük a perceptron számítás eredményét, amit megjelnítünk szabványos kimeneten.
	</para>	
	<para>
	<programlisting language = "C++">
          <![CDATA[ 	 
	#include <iostream>
#include "png++/png.hpp"
#include "mlp.hpp"
using namespace std;
using namespace png;
int main ( int argc, char *argv[] )
{
image <rgb_pixel> png_image (argv[1]);
int size = png_image.get_width() * png_image.get_height();
Perceptron* p = new Perceptron(3, size, 256, 1);
double* image = new double[size];
for (int i{0}; i < png_image.get_width(); i++)
for (int j{0}; j < png_image.get_height(); j++)
image[i * png_image.get_width() + j] = png_image[i][j].red;
double value = (*p)(image);
cout <<" "<< value << endl;
delete p;
delete [] image;
}
        ]]>
        </programlisting>
</para>
<para>
	<mediaobject>
            <imageobject>
                <imagedata fileref="perceptron.png"></imagedata>
            </imageobject>
        </mediaobject>
</para>
	</section>
</chapter>
